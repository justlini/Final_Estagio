<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Advanced Operations </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="Advanced Operations ">
    <meta name="generator" content="docfx 2.51.0.0">
    
    <link rel="shortcut icon" href="../favicon.ico">
    <link rel="stylesheet" href="../styles/docfx.vendor.css">
    <link rel="stylesheet" href="../styles/docfx.css">
    <link rel="stylesheet" href="../styles/main.css">
    <meta property="docfx:navrel" content="../toc">
    <meta property="docfx:tocrel" content="toc">
    
    
    
  </head>
  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <div id="wrapper">
      <header>
        
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              <a class="navbar-brand" href="../index.html">
                <img id="logo" src="../images/zbra-logo.png" height="46" width="100" alt="">
              </a>
                  </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
                
                <ul class="nav level1 navbar-nav">
                      <li>
                          <a href="../api/Symbol.RFID3.html" title="API Documentation">API Documentation</a>
                      </li>
                      <li>
                          <a href="../articles/introduction.html" title="Programmer's Guide">Programmer's Guide</a>
                      </li>
                </ul>    </div>
          </div>
        </nav>
        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div role="main" class="container body-content hide-when-search">
        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div>
              <div class="sidefilter">
                <form class="toc-filter">
                  <span class="glyphicon glyphicon-filter filter-icon"></span>
                  <input type="text" id="toc_filter_input" placeholder="Enter here to filter..." onkeypress="if(event.keyCode==13) {return false;}">
                </form>
              </div>
              <div class="sidetoc">
                <div class="toc" id="toc">
                  
                  <ul class="nav level1">
                    <li class="">
                      <a href="introduction.html" title="Introduction" class="">Introduction</a>
                    </li>
                    <li class="">
                      <span class="expand-stub"></span>
                      <a class="">Generic Reader Interface</a>
                        
                        <ul class="nav level2">
                          <li class="">
                            <a href="connect_to_reader.html" title="Connecting to Reader" class="">Connecting to Reader</a>
                          </li>
                          <li class="">
                            <a href="reader_cap.html" title="Knowing the Reader Capabilities" class="">Knowing the Reader Capabilities</a>
                          </li>
                          <li class="">
                            <a href="config_reader.html" title="Configuring the Reader" class="">Configuring the Reader</a>
                          </li>
                          <li class="">
                            <a href="mang_events.html" title="Managing Events" class="">Managing Events</a>
                          </li>
                          <li class="">
                            <a href="mang_tags.html" title="Managing Tags" class="">Managing Tags</a>
                          </li>
                          <li class="">
                            <a href="basic_op.html" title="Basic Operations" class="">Basic Operations</a>
                          </li>
                          <li class="active">
                            <a href="advance_op.html" title="Advanced Operations" class="active">Advanced Operations</a>
                          </li>
                          <li class="">
                            <a href="tag_loc.html" title="Tag Locationing" class="">Tag Locationing</a>
                          </li>
                          <li class="">
                            <a href="nxp_cmd.html" title="NXP Commands" class="">NXP Commands</a>
                          </li>
                          <li class="">
                            <a href="gen2v2_cmds.html" title="Gen2 V2 Commands" class="">Gen2 V2 Commands</a>
                          </li>
                          <li class="">
                            <a href="impinj_cmd.html" title="Impinj Commands" class="">Impinj Commands</a>
                          </li>
                          <li class="">
                            <a href="disconnect_read.html" title="Disconnecting from the Reader" class="">Disconnecting from the Reader</a>
                          </li>
                        </ul>  </li>
                    <li class="">
                      <span class="expand-stub"></span>
                      <a class="">Reader Management Interface</a>
                        
                        <ul class="nav level2">
                          <li class="">
                            <a href="RM/conn_reader.html" title="Connecting to the Reader" class="">Connecting to the Reader</a>
                          </li>
                          <li class="">
                            <a href="RM/firmware_update.html" title="Updating Firmware of the Software" class="">Updating Firmware of the Software</a>
                          </li>
                          <li class="">
                            <a href="RM/license_mgmt.html" title="License Management" class="">License Management</a>
                          </li>
                          <li class="">
                            <a href="RM/read_points.html" title="Read Points" class="">Read Points</a>
                          </li>
                          <li class="">
                            <a href="RM/antenna_modes.html" title="Antenna Modes" class="">Antenna Modes</a>
                          </li>
                          <li class="">
                            <a href="RM/sys_info.html" title="Reader and System Information" class="">Reader and System Information</a>
                          </li>
                          <li class="">
                            <a href="RM/read_config.html" title="Managing Reader Configurations" class="">Managing Reader Configurations</a>
                          </li>
                          <li class="">
                            <a href="RM/llrp_config.html" title="Managing LLRP connection and configuration" class="">Managing LLRP connection and configuration</a>
                          </li>
                          <li class="">
                            <a href="RM/usb_mode.html" title="USB Operation Mode" class="">USB Operation Mode</a>
                          </li>
                          <li class="">
                            <a href="RM/gpi_debounce.html" title="GPI Debounce Time" class="">GPI Debounce Time</a>
                          </li>
                          <li class="">
                            <a href="RM/local_time.html" title="Local Time" class="">Local Time</a>
                          </li>
                          <li class="">
                            <a href="RM/time_zone.html" title="Time Zone" class="">Time Zone</a>
                          </li>
                          <li class="">
                            <a href="RM/user_led.html" title="User LED" class="">User LED</a>
                          </li>
                          <li class="">
                            <a href="RM/reader_stats.html" title="Reader Statistics" class="">Reader Statistics</a>
                          </li>
                          <li class="">
                            <a href="RM/restart.html" title="Restarting the Reader" class="">Restarting the Reader</a>
                          </li>
                          <li class="">
                            <a href="RM/diconn.html" title="Disconnecting the Reader" class="">Disconnecting the Reader</a>
                          </li>
                          <li class="">
                            <a href="RM/cable_loss.html" title="Cable Loss Compensation" class="">Cable Loss Compensation</a>
                          </li>
                          <li class="">
                            <a href="RM/idle_mode.html" title="Idle Mode" class="">Idle Mode</a>
                          </li>
                          <li class="">
                            <a href="RM/power_nego.html" title="Power Negotiation" class="">Power Negotiation</a>
                          </li>
                          <li class="">
                            <a href="RM/region_config.html" title="Region configuration" class="">Region configuration</a>
                          </li>
                          <li class="">
                            <a href="RM/app_deploy.html" title="User App Deployment" class="">User App Deployment</a>
                          </li>
                          <li class="">
                            <a href="RM/usr_mang.html" title="User Management" class="">User Management</a>
                          </li>
                        </ul>  </li>
                  </ul>        </div>
              </div>
            </div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="">
<h1 id="advanced-operations">Advanced Operations</h1>

<p><strong>Tag Event Reporting</strong></p>
<p>This feature can be used to enable reporting tag visibility changes. If a reader supports this feature it reports the Reader Capability TagEventReportingSupported as true. The following code snippet enabled reporting tags when a Tag is visible/Gone out of Visibility/Back to visibility for at least 100 ms;</p>
<pre><code>```csharp
TriggerInfo triggerInfo = new TriggerInfo();

triggerInfo.EnableTagEventReport = true;

triggerInfo.TagEventReportInfo.ReportNewTagEvent = TAG_EVENT_REPORT_TRIGGER.MODERATED;

triggerInfo.TagEventReportInfo.ReportTagInvisibleEvent = TAG_EVENT_REPORT_TRIGGER.MODERATED;

triggerInfo.TagEventReportInfo.ReportTagBackToVisibilityEvent = TAG_EVENT_REPORT_TRIGGER.MODERATED;

triggerInfo.TagEventReportInfo.NewTagEventModeratedTimeoutMilliseconds = 100;

triggerInfo.TagEventReportInfo.TagInvisibleEventModeratedTimeoutMilliseconds = 100;

triggerInfo.TagEventReportInfo.TagBackToVisibilityModeratedTimeoutMilliseconds = 100;

rfid3.Actions.Inventory.Perform(null, triggerInfo, null);
```
</code></pre><p><strong>TAG_EVENT</strong> reported as part of <strong>TAG_DATA</strong> indicates the visibility state of the Tag.</p>
<h1 id="using-pre-filters">Using Pre-Filters</h1>
<p>Pre-filters are same as the Select command of C1G2 specification. Once applied, pre-filters are applied prior to Inventory and Access operations. </p>
<h2 id="introduction">Introduction</h2>
<h3 id="singulation">Singulation</h3>
<p>Singulation refers to the method of identifying an individual Tag in a multiple-Tag environment. RFID Readers could support State-Aware or State-Unaware pre-filtering (or singulation) which is indicated by the boolean flag <em>IsTagInventoryStateAwareSingulationSupported</em> in the <strong>ReaderCapabilities</strong> class.</p>
<p>In order to filter tags that match a specific condition, it is necessary to use the tag-sessions and their states (setting the tags to different states based on match criteria- <em>rfid3.Actions.PreFilters.Add</em>) so that while performing inventory, tags can be instructed to participate (singulation - <em>rfid3.Config.Antennas[1].SetSingulationControl</em>) or not participate in the inventory based on their states. </p>
<h3 id="sessions-and-inventoried-flags">Sessions and Inventoried Flags</h3>
<p>Tags provide 4 sessions (denoted S0, S1, S2, and S3) and maintain an independent inventoried flag for each session. Each of the four inventoried flags has two values, denoted A and B. These inventoried flag of each session can be set to A or B based on match criteria using method rfid3.Actions.PreFilters.Add.</p>
<h3 id="selected-flag">Selected Flag</h3>
<p>Tags provide a selected flag, SL, which can be asserted or deasserted based on match criteria using method <em>rfid3.Actions.PreFilters.Add</em></p>
<h3 id="state-unaware-singulation">State-Unaware Singulation</h3>
<p>In state-unaware singulation the Reader permits 6 options (as enumerated by <strong>STATE_UNAWARE_ACTION</strong>) of filtering tags. This is more simplified than state-aware singulation.</p>
<table>
<thead>
<tr>
<th>Option</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>STATE_UNAWARE_ACTION_SELECT_NOT_UNSELECT</td>
<td>Matching tags: SELECT , Non-matching tags: UNSELECT</td>
</tr>
<tr>
<td>STATE_UNAWARE_ACTION_SELECT</td>
<td>Matching tags: SELECT, Non-matching tags: do nothing</td>
</tr>
<tr>
<td>STATE_UNAWARE_ACTION_NOT_UNSELECT</td>
<td>Matching tags: do nothing, Non-matching tags: UNSELECT</td>
</tr>
<tr>
<td>STATE_UNAWARE_ACTION_UNSELECT</td>
<td>Matching tags: UNSELECT , Non-matching tags: do nothing</td>
</tr>
<tr>
<td>STATE_UNAWARE_ACTION_UNSELECT_NOT_SELECT</td>
<td>Matching tags: UNSELECT , Non-matching tags: SELECT</td>
</tr>
<tr>
<td>STATE_UNAWARE_ACTION_NOT_SELECT</td>
<td>Matching tags: do nothing, Non-matching tags: SELECT</td>
</tr>
</tbody>
</table>
<h3 id="state-aware-singulation">State-Aware Singulation</h3>
<p>In state-aware singulation the Application can specify detailed controls for singulation: Action and Target. </p>
<p>Action indicates whether matching Tags assert or deassert SL (Selected Flag), or set their inventoried flag to A or to B. Tags conforming to the match criteria specified using the method <em>rfid3.Actions.PreFilters.Add</em> are considered matching and the remaining are non-matching. </p>
<p>Target indicates whether to modify a Tag’s SL flag or its inventoried flag, and in the case of inventoried it further specifies one of four sessions.</p>
<table>
<thead>
<tr>
<th>Session</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>SESSION_S0</td>
<td>S0</td>
</tr>
<tr>
<td>SESSION_S1</td>
<td>S1</td>
</tr>
<tr>
<td>SESSION_S2</td>
<td>S2</td>
</tr>
<tr>
<td>SESSION_S3</td>
<td>S3</td>
</tr>
</tbody>
</table>
<h3 id="truncate-action">Truncate Action</h3>
<p>Truncate action specifies whether a Tag backscatters its entire EPC, or only that portion of the EPC immediately following Mask. During truncated replies a Tag substitutes 00000 for the PC bits. Truncated replies are always followed by the CRC-16 in EPC memory 00h to 0Fh; a Tag does not re compute this CRC for a truncated reply.</p>
<h3 id="applying-pre-filters">Applying Pre-Filters</h3>
<p>The following are the steps to use pre-filters:</p>
<ul>
<li>Add pre-filters </li>
<li>Set appropriate singulation controls </li>
<li>Perform Inventory or Access operation </li>
</ul>
<h3 id="add-pre-filters">Add pre-filters</h3>
<p>Each RFID Reader supports a maximum number of Pre-Filters per Antenna as indicated by <em>rfid3.ReaderCapabilites.MaxNumPreFilters</em> property which can be known using the ReaderCapabilities. </p>
<p>The application can set pre-filters using <em>rfid3.Actions.PreFilters.Add</em> and remove using <em>rfid3.Actions.PreFilters.Delete</em>.</p>
<h3 id="state-unaware-singulation-1">State-Unaware Singulation</h3>
<pre><code class="lang-csharp">// Add state unaware pre-filter

PreFilters.PreFilter filter = new PreFilters.PreFilter();

byte[] tagMask = new byte[2] { 0x12, 0x11 };

filter.AntennaID = 3;// Set this filter for Antenna ID 3

filter.TagPattern = tagMask;// Tags which starts with 0x1211

filter.TagPatternBitCount = (uint)tagMask.Length * 8;

filter.BitOffset = 32; // skip PC bits (always it should be in bit length)

filter.MemoryBank = MEMORY_BANK.MEMORY_BANK_EPC;

filter.FilterAction = FILTER_ACTION.FILTER_ACTION_STATE_UNAWARE; // use state unaware singulation

filter.StateUnawareAction.Action = STATE_UNAWARE_ACTION.STATE_UNAWARE_ACTION_UNSELECT;  // do not select the tags that match the pre-filter criteria

rfid3.Actions.PreFilters.Add(filter);
</code></pre><h3 id="state-aware-singulation-1">State-Aware Singulation</h3>
<pre><code class="lang-csharp">// Add state aware pre-filter

PreFilters.PreFilter filter = new PreFilters.PreFilter();

byte[] tagMask = new byte[2] { 0x12, 0x11 };

filter.AntennaID = 3;// Set this filter for Antenna ID 3

filter.TagPattern = tagMask;// Tags which starts with 0x1211

filter.TagPatternBitCount = (uint)tagMask.Length * 8;

filter.BitOffset = 32; // skip PC bits (always it should be in bit length)

filter.MemoryBank = MEMORY_BANK.MEMORY_BANK_EPC;

filter.FilterAction = FILTER_ACTION.FILTER_ACTION_STATE_AWARE; // use state aware singulation

filter.StateAwareAction.Target = TARGET.TARGET_INVENTORIED_STATE_S1; // inventoried flag of session S1 of matching tags to B

filter.StateAwareAction.Action = STATE_AWARE_ACTION.STATE_AWARE_ACTION_INV_B; // not to select tags that match the criteria

rfid3.Actions.PreFilters.Add(filter);

// It is also required to set appropriate singulation control not to 

// get tags with inventoried flag B for session 1
</code></pre><h3 id="set-appropriate-singulation-controls">Set appropriate singulation controls</h3>
<p>Now that the pre-filters are set (i.e. Tags are classified into matching or non-matching criteria), the Application needs to specify which tags should participate in the Inventory using <em>rfid3.Config.Antennas[1].SetSingulationControl()</em>. Singulation Control must be specified with respect to each Antenna like Pre-Filters.  </p>
<h3 id="state-unaware-singulation-2">State-Unaware Singulation</h3>
<pre><code class="lang-csharp">// Set the singulation control

Antennas.SingulationControl s1_singulationControl = new Antennas.SingulationControl();

s1_singulationControl.Session = SESSION.SESSION_S1; // Set session to operate on S1. If not specified, reader uses its own way of implementing the state-unware singulation

rfid3.Config.Antennas[3].SetSingulationControl(s1_singulationControl);

State-Aware Singulation
// Set the singulation control

Antennas.SingulationControl s1_singulationControl = new Antennas.SingulationControl();

s1_singulationControl.Session = SESSION.SESSION_S1;

s1_singulationControl.Action.InventoryState = INVENTORY_STATE.INVENTORY_STATE_B;

s1_singulationControl.Action.SLFlag = SL_FLAG.SL_FLAG_DEASSERTED;

s1_singulationControl.Action.PerformStateAwareSingulationAction = true;

rfid3.Config.Antennas[3].SetSingulationControl(s1_singulationControl);
</code></pre><h3 id="perform-inventory-or-access-operation">Perform Inventory or Access operation</h3>
<p>Inventory or Access operation when performed after setting pre-filters, will use the tags filtered out of pre-filters for their operation.</p>
<h2 id="using-triggers">Using Triggers</h2>
<p>Triggers are the conditions that should be satisfied in order to start or stop an operation (Inventory or Access Sequence). This information can be specified using <strong>TriggerInfo</strong> class. The application can also configure the Tag-Report trigger which indicates when to receive ‘n’ unique Tag-Reports from the Reader. </p>
<p>The following are some use-cases of using TRIGGER_INFO:</p>
<ol>
<li><p>GPI based Inventory – Start inventory when GPI port ‘n’ changes state to ‘TRUE’ and stop inventory when GPI port ‘n’ changes state to ‘FALSE’. </p>
<pre><code class="lang-csharp">TriggerInfo triggerInfo = new TriggerInfo();

// start trigger GPI port 1 changes to true

triggerInfo.StartTrigger.Type = START_TRIGGER_TYPE.START_TRIGGER_TYPE_GPI;

triggerInfo.StartTrigger.GPI.PortNumber = 1;

triggerInfo.StartTrigger.GPI.GPIEvent = true;

// stop trigger GPI port 1 changes to false

triggerInfo.StopTrigger.Type = STOP_TRIGGER_TYPE.STOP_TRIGGER_TYPE_GPI_WITH_TIMEOUT;

triggerInfo.StopTrigger.GPI.PortNumber = 1;

triggerInfo.StopTrigger.GPI.GPIEvent = false; 

triggerInfo.StopTrigger.GPI.Timeout = 1000; // 1 sec

// report back each tag report as and when it is read by Reader

triggerInfo.TagReportTrigger = 1;
</code></pre></li>
<li><p>Periodic Inventory – Start inventory at a specified time for a specified duration repeatedly. </p>
<pre><code class="lang-csharp">TriggerInfo triggerInfo = new TriggerInfo();

// start inventory on 12th of this month and 12am and runs 200 milliseconds of every 2 seconds

triggerInfo.StartTrigger.Type = START_TRIGGER_TYPE.START_TRIGGER_TYPE_PERIODIC;

// perform inventory for 2 seconds

triggerInfo.StartTrigger.Periodic.Period = 2000; 

// start time

    DateTime currentTime = DateTime.UtcNow;

    DateTime startTime = new DateTime(currentTime.Year, currentTime.Month, 12, 12, currentTime.Minute, currentTime.Second);

triggerInfo.StartTrigger.Periodic.StartTime = startTime;

// stop trigger 

triggerInfo.StopTrigger.Type = STOP_TRIGGER_TYPE.STOP_TRIGGER_TYPE_DURATION;

// stop after 200 milliseconds

triggerInfo.StopTrigger.Duration = 200; 

// report back all read tags after completion of one round of inventory (i.e. one period)

triggerInfo.TagReportTrigger = 0;
</code></pre></li>
<li><p>Perform ‘n’ Rounds of Inventory with a timeout – Start condition could be any; Stop condition is to perform ‘n’ rounds of inventory and then stop or stop inventory after the specified timeout. </p>
<pre><code class="lang-csharp">TriggerInfo triggerInfo = new TriggerInfo();

// start inventory immediate

triggerInfo.StartTrigger.Type = START_TRIGGER_TYPE.START_TRIGGER_TYPE_IMMEDIATE;

// stop trigger 

triggerInfo.StopTrigger.Type = STOP_TRIGGER_TYPE.STOP_TRIGGER_TYPE_N_ATTEMPTS_WITH_TIMEOUT;

// perform 3 rounds of inventory

triggerInfo.StopTrigger.NumAttempts.N = 3; 

// timeout after 3 seconds

triggerInfo.StopTrigger.NumAttempts.Timeout = 3000; 

// report back all read tags after 3 rounds of inventory

triggerInfo.TagReportTrigger = 0;
</code></pre></li>
<li><p>Read ‘n’ Tags with a timeout – Start condition could be any; Stop condition is to stop after reading ‘n’ tags or stop inventory after the specified timeout. </p>
<pre><code class="lang-csharp">TriggerInfo triggerInfo = new TriggerInfo();

// start inventory immediate

triggerInfo.StartTrigger.Type = START_TRIGGER_TYPE.START_TRIGGER_TYPE_IMMEDIATE;

// stop trigger 

triggerInfo.StopTrigger.Type = STOP_TRIGGER_TYPE.STOP_TRIGGER_TYPE_TAG_OBSERVATION_WITH_TIMEOUT;

triggerInfo.StopTrigger.TagObservation.N = 100; // stop inventory after reading 100 tags

triggerInfo.StopTrigger.NumAttempts.TimeoutMilliseconds = 3000; // timeout after 3 seconds

// report back all read tags after getting 100 unique tags or after 3 seconds

triggerInfo.TagReportTrigger = 0;
</code></pre></li>
<li><p>Periodic Tag Reporting - Tags will be periodically reported on a specified timer interval elapsed. ReportTriggers takes precedence over TagReportTrigger property. In order to use TagReportTrigger feature, set the ReportTriggers.Period set to 0. </p>
<pre><code class="lang-csharp">TriggerInfo triggerInfo = new TriggerInfo();

// Tags will be periodically reported in every 10 seconds

triggerInfo.ReportTriggers.Period = 10;
</code></pre></li>
<li><p>Extra Trigger - The support for array of start / stop triggers are added as extra triggers in TriggerInfo class. The field IsZebraTriggerSupported in ReaderCapabilities determines whether reader supports this feature or not. This allows to configure multiple start and start triggers. The reader internally pre-empts and execute the triggers when it meets the trigger condition. Reader supports maximum of seven extra triggers.</p>
<pre><code class="lang-csharp">// Configure first pair of triggers

triggerInfo.StartTrigger.Type = START_TRIGGER_TYPE.START_TRIGGER_TYPE_GPI;

triggerInfo.StartTrigger.GPI.PortNumber = 1;

triggerInfo.StartTrigger.GPI.GPIEvent = false;

triggerInfo.StartTrigger.GPI.Timeout = 0;

triggerInfo.StopTrigger.Type = STOP_TRIGGER_TYPE.STOP_TRIGGER_TYPE_GPI_WITH_TIMEOUT;

triggerInfo.StopTrigger.GPI.PortNumber = 1;

triggerInfo.StopTrigger.GPI.GPIEvent = true;

triggerInfo.StopTrigger.GPI.Timeout = 0;


</code></pre></li>
</ol>
<pre><code>// Configure Extra Triggers

// 1. Start Trigger - Distance

triggerInfo.ExtraTriggers[0].StartTrigger.Type = START_TRIGGER_TYPE.START_TRIGGER_TYPE_DISTANCE;

triggerInfo.ExtraTriggers[0].StartTrigger.Distance.DistanceKms = 5;

// 1. Stop Trigger - Time Lapse

triggerInfo.ExtraTriggers[0].StopTrigger.Type = STOP_TRIGGER_TYPE.STOP_TRIGGER_TYPE_TIMELAPSE;

triggerInfo.ExtraTriggers[0].StopTrigger.TimeLapse.PeriodicDurationSeconds = 500;

triggerInfo.ExtraTriggers[0].StopTrigger.TimeLapse.TotalDurationSeconds = 1000;



// 2. Start Trigger - Time Lapse

triggerInfo.ExtraTriggers[1].StartTrigger.Type = START_TRIGGER_TYPE.START_TRIGGER_TYPE_TIMELAPSE;

triggerInfo.ExtraTriggers[1].StartTrigger.TimeLapse.StartTime = new TimeSpan(15, 30, 50);

triggerInfo.ExtraTriggers[1].StartTrigger.TimeLapse.Period = 50; // In 50 Seconds

// 2. Stop Trigger - Duration

triggerInfo.ExtraTriggers[1].StopTrigger.Type = STOP_TRIGGER_TYPE.STOP_TRIGGER_TYPE_DURATION;

triggerInfo.ExtraTriggers[1].StopTrigger.Duration = 6000;

```
</code></pre><h2 id="inventory">Inventory</h2>
<h3 id="inventory-with-triggers">Inventory with Triggers</h3>
<p>There are various situations that act as conditions (triggers) for performing inventory. </p>
<p>Refer section “Using Triggers” to configure Triggers.</p>
<p>The following shows an example of performing 1 round of Inventory on Antennas 1 and 3.</p>
<pre><code class="lang-csharp">TriggerInfo triggerInfo = new TriggerInfo();

// perform inventory on antenna 1 &amp; 3

ushort[] antennaList = new ushort[2] { 1, 3 };

AntennaInfo antennaInfo = new AntennaInfo(antennaList);

// start inventory immediate

triggerInfo.StartTrigger.Type = START_TRIGGER_TYPE.START_TRIGGER_TYPE_IMMEDIATE;

// stop trigger 

triggerInfo.StopTrigger.Type = STOP_TRIGGER_TYPE.STOP_TRIGGER_TYPE_N_ATTEMPTS_WITH_TIMEOUT;

// perform 1 round of inventory

triggerInfo.StopTrigger.NumAttempts.N = 1; 

triggerInfo.StopTrigger.NumAttempts.Timeout = 0; // reader default timeout

// report back all read tags after 1 round of inventor

triggerInfo.TagReportTrigger = 0;

// perform inventory

rfid3.Actions.Inventory.Perform(null, triggerInfo, antennaInfo);
</code></pre><h3 id="using-post-filters">Using Post-Filters</h3>
<p>Post-filters are those filters which are applied on the Tags that the reader received through the pre-filters (if any).</p>
<p>Post-filters allow the application to set one or two tag patterns and to specify a condition as a combination of the patterns.</p>
<p>The following snippet shows setting a post-filter that does not get tags starting with 0x1122 and 0x2233.</p>
<pre><code class="lang-csharp">PostFilter postFilter = new PostFilter();

byte[] tagMask = new byte[2] { 0xff, 0xff };

// Tag Pattern A 

postFilter.TagPatternA.MemoryBank = MEMORY_BANK.MEMORY_BANK_EPC;

postFilter.TagPatternA.TagPattern = new byte[2] { 0x11, 0x22 };

postFilter.TagPatternA.TagPatternBitCount = 2 * 8;

postFilter.TagPatternA.BitOffset = 0;

postFilter.TagPatternA.TagMask = tagMask;

postFilter.TagPatternA.TagMaskBitCount = (uint)tagMask.Length * 8;

// Tag Pattern B

postFilter.TagPatternB.MemoryBank = MEMORY_BANK.MEMORY_BANK_EPC;

postFilter.TagPatternB.TagPattern = new byte[2] { 0x22, 0x33 };

postFilter.TagPatternB.TagPatternBitCount = 2 * 8;

postFilter.TagPatternB.BitOffset = 32; //skip PC 

postFilter.TagPatternB.TagMask = tagMask;

postFilter.TagPatternB.TagMaskBitCount = (uint)tagMask.Length * 8;

postFilter.MatchPattern = MATCH_PATTERN.NOTA_AND_NOTB;

// perform inventory with post filter

rfid3.Actions.Inventory.Perform(postFilter, null, null);
</code></pre><h3 id="using-rssi-filtering-in-post-filters">Using RSSI Filtering in Post Filters</h3>
<p>Starting from version RFID_API3_5_1 onwards, applications can use RSSI based filtering if supported by the reader. This is indicated by the field IsRssiFilterSupported of ReaderCaps. The following code snippet does filtering of tags which have RSSI value in range -40 to -10. </p>
<pre><code class="lang-csharp">PostFilter postFilter = new PostFilter();

postFilter.UseRSSIRangeFilter = true;

postFilter.RssiRangeFilter.MatchRange = MATCH_RANGE.WITHIN_RANGE;

postFilter.RssiRangeFilter.PeakRSSILowerLimit = -40;

postFilter.RssiRangeFilter.PeakRSSIUpperLimit = -10;

rfid3.Actions.Inventory.Perform(postFilter, null, null);
</code></pre><h2 id="access">Access</h2>
<h3 id="using-access-filters">Using Access-Filters</h3>
<p>In order to perform an access operation on multiple tags, the Application can set ACCESS_FILTER to filter the required tags. If ACCESS_FILTER is not specified, the operation will be performed on all Tags. In any case, the PRE_FILTER(s) if any is set will apply prior to ACCESS_FILTER.</p>
<p>The following Access-filter gets all tags that have zeroed Reserved memory bank.</p>
<pre><code class="lang-csharp">AccessFilter accessFilter = new AccessFilter();

byte[] tagMask = new byte[8] { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff };

// Tag Pattern A 

accessFilter.TagPatternA.MemoryBank = MEMORY_BANK.MEMORY_BANK_RESERVED;

accessFilter.TagPatternA.TagPattern = new byte[8] { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };

accessFilter.TagPatternA.TagPatternBitCount = 8 * 8;

accessFilter.TagPatternA.BitOffset = 0;

accessFilter.TagPatternA.TagMask = tagMask;

accessFilter.TagPatternA.TagMaskBitCount = (uint)tagMask.Length * 8;

// Tag Pattern B

accessFilter.TagPatternB = null;

accessFilter.MatchPattern = MATCH_PATTERN.A;
</code></pre><h3 id="access-operation-on-multiple-tags">Access Operation on Multiple Tags</h3>
<p>Performing a single Access operation on multiple tags is an asynchronous operation. The function issues the access-operation and returns. The Reader performs one round of inventory using pre-filters if any, and then applies the access-filters and the resultant tags are subject to the access-operation. When the access operation is complete, the Dll signals the rfid3.Events.StatusNotify event with event data as ACCESS_STOP_EVENT. The Application can call the method rfid3.Actions.TagAccess.GetLastAccessResult to know the result. In case of Read access operation (rfid3.Actions.TagAccess.ReadEvent) the event rfid3.Events.ReadNotify is signalled when Tags are reported.</p>
<p>The following snippet shows a sample write-access operation:</p>
<pre><code class="lang-csharp">// Create Event to signify access operation complete

AutoResetEvent AccessComplete;

AccessComplete = new AutoResetEvent(false);

rfid3.Events.NotifyAccessStartEvent = true;

rfid3.Events.NotifyAccessStopEvent = true;

rfid3.Events.StatusNotify += new Events.StatusNotifyHandler(Events_StatusNotify);

// Status Notification from the reader

public void Events_StatusNotify(object sender, Events.StatusEventArgs e)

{

    switch (e.StatusEventData.StatusEventType)

    {

        case Events.STATUS_EVENT_TYPE.ACCESS_START_EVENT:

            AccessComplete.Reset();

            break;

        case Events.STATUS_EVENT_TYPE.ACCESS_STOP_EVENT:

            AccessComplete.Set();

            break;

    }

}

// Access Filter - EPC ID starting with 0x1122

AccessFilter accessFilter = new AccessFilter();

byte[] tagMask = new byte[2] { 0xff, 0xff };

// Tag Pattern A 

accessFilter.TagPatternA.MemoryBank = MEMORY_BANK.MEMORY_BANK_EPC;

accessFilter.TagPatternA.TagPattern = new byte[2] { 0x11, 0x22};

accessFilter.TagPatternA.TagPatternBitCount = 2 * 8;

accessFilter.TagPatternA.BitOffset = 0;

accessFilter.TagPatternA.TagMask = tagMask;

accessFilter.TagPatternA.TagMaskBitCount = (uint)tagMask.Length * 8;

// Tag Pattern B

accessFilter.TagPatternB = null;

accessFilter.MatchPattern = MATCH_PATTERN.A;

// Write user memory bank data

TagAccess.WriteAccessParams writeParams = new TagAccess.WriteAccessParams();

byte[] writeData = new byte[4] { 0xff, 0xff, 0xff, 0xff };

writeParams.AccessPassword = 0;

writeParams.MemoryBank = MEMORY_BANK.MEMORY_BANK_USER;

writeParams.ByteOffset = 0;

writeParams.WriteDataLength = (uint)writeData.Length;

writeParams.WriteData = writeData;

// Asynchronous write operation

rfid3.Actions.TagAccess.WriteEvent(writeParams, accessFilter, null);

// wait for access operation to complete

AccessComplete.WaitOne();

uint successCount = 0;

uint failureCount = 0;

// Get Access operation results

rfid3.Actions.TagAccess.GetLastAccessResult(ref successCount, ref failureCount);
</code></pre><h3 id="using-access-sequence">Using Access Sequence</h3>
<p>The Application can issue multiple access operations on a single go using Access-Sequence API. This is useful when each tag from a set of (access-filtered) tags is to be subject to an order of access operations.</p>
<p>The maximum number of access-operations that can be specified in an access sequence is specified in rfid3.ReaderCapabilites.MaxNumOperationsInAccessSequenceof ReaderCapabilities class.</p>
<p>The operations will be performed in the same order in which it is added to it sequence. An operation can be removed from the sequence using rfid3.Actions.TagAccess.OperationSequence.Delete and finally de-initialized if no more needed by calling the function rfid3.Actions.TagAccess.OperationSequence.DeleteAll().</p>
<pre><code class="lang-csharp">// Create Event to signify access sequence operation complete

AutoResetEvent AccessComplete;

AccessComplete = new AutoResetEvent(false);

// add Write Access operation - Write to User memory

TagAccess.Sequence.Operation op1 = new TagAccess.Sequence.Operation();

op1.AccessOperationCode = ACCESS_OPERATION_CODE.ACCESS_OPERATION_WRITE;

op1.WriteAccessParams.MemoryBank = MEMORY_BANK.MEMORY_BANK_USER;

op1.WriteAccessParams.AccessPassword = 0;

op1.WriteAccessParams.ByteOffset = 0;

op1.WriteAccessParams.WriteData = new byte[4] { 0x55, 0x66, 0x77, 0x88 };

op1.WriteAccessParams.WriteDataLength = 4;

rfid3.Actions.TagAccess.OperationSequence.Add(op1);

// add Write Access operation - Write to Reserved memory bank

TagAccess.Sequence.Operation op2 = new TagAccess.Sequence.Operation();

op2.AccessOperationCode = ACCESS_OPERATION_CODE.ACCESS_OPERATION_WRITE;

op2.WriteAccessParams.MemoryBank = MEMORY_BANK.MEMORY_BANK_USER;

op2.WriteAccessParams.AccessPassword = 0;

op2.WriteAccessParams.ByteOffset = 0;

op2.WriteAccessParams.WriteData = new byte[4] { 0xBB, 0xBB, 0xBB, 0xBB };

op2.WriteAccessParams.WriteDataLength = 4;

rfid3.Actions.TagAccess.OperationSequence.Add(op1);

// perform access sequence

rfid3.Actions.TagAccess.OperationSequence.PerformSequence(null, null, null);

// wait for access operation complete

AccessComplete.WaitOne();

// get the access operation result

uint successCount = 0;

uint failureCount = 0;

rfid3.Actions.TagAccess.GetLastAccessResult(ref successCount, ref failureCount);

// if the access operation is to be terminated without meeting stop trigger (if specified), 

// stopSequence method can be called

rfid3.Actions.TagAccess.OperationSequence.StopSequence();
</code></pre></article>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <div class="contribution">
                <ul class="nav">
                </ul>
              </div>
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
              <!-- <p><a class="back-to-top" href="#top">Back to top</a><p> -->
              </nav>
            </div>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            
            <span></span>
          </div>
        </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="../styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="../styles/docfx.js"></script>
    <script type="text/javascript" src="../styles/main.js"></script>
  </body>
</html>
